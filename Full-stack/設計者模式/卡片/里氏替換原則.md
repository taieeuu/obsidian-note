---
Date: 2023-12-27
tags:
  - 設計者模式
---
## 原則

- 內容: 任何基類可以出現的地方，子類一定可以出現
- Why 里氏替換:
    - 繼承是面對對象編程三大特性之一，能給程序編程帶來巨大的便利，但也帶來弊端，像是給程序帶來侵入性
        - 如果一個類被其他類所繼承，當這個類需要被修改的時候，那就必須考慮到所有的子類
    - 所以當父類需要被修改的時候，有可能導致子類的出錯，增加程序之間的耦和性
    - 里氏替換原則是繼成父用的基石，只有延伸類才可替換基類，並且不會影響程序運行時，我們的代碼才會被真正的復用，降低程序出錯率，這樣才能保證升級後的兼容性。
## 原則規範

- 原則
    - 保證基類所傭有的性質在子類中仍然成立
    - 子類擴展父類的功能，但是不能改變父類原有的功能
- 如何規範地遵循里氏替換原則:
    - 子類必須完全實現父類的抽象類，但不能覆蓋父類得非抽象方法
    - 子類可以實現自己特有的方法
    - 當子類的方法實現父類的抽象方法時，方法的後製條件要比父類更嚴格
    - 子類的實例可以替代任何父類的實例，但反之不成立
## 實例
### 子類必須完全實現父類的抽象類，但不能覆蓋父類得非抽象方法
![[里氏替換原則 1.png|600]]

- SuperCalculator繼承父類Calculator且改成了n1-n2，而在Main中，當c1改成c2雖然戴法能運行，但既然變量定義為sum就代表我們所期望的結果為相加的結果，之後如果調用，很有可能影響我們之後的功能。
- 更嚴重的情況: 如果SuperCalculator還有一個子類，那它改變了非抽象方法，就會對繼承的系統都會遭受到破壞，所以對於非抽象方法就不要重寫
### 子類可以實現自己特有的方法
![[里氏替換原則 2.png|600]]

- 除了父類定義好的方法，子類可以自己實現自己特有的方法對功能進行拓展，但還是要注意第一條規範，不能覆蓋非抽象類方法，因為我們要保證，既使拓展之後，父類出現的地方換成子類也不會對程序的正常運行造成影響。
### 當子類的方法實現父類的抽象方法時，方法的後製條件要比父類更嚴格
![[里氏替換原則 3.png|600]]

- SuperCalculator比基類calcuator更加寬鬆，更何況基類的stringToList返回值為ArrayList<String/>。
### 子類的實例可以替代任何父類的實例，但反之不成立
![[里氏替換原則 4.png|600]]

- (圖示)c2.substract中的c2替換為c1是不行那就會運行不了，因為父類沒有substract方法，總而言之里氏替換原則只允許，子類替換父類，父類不能替換子類。
## [Python Code](https://github.com/turingplanet/design-patterns-series/tree/main/v8_liskov_substitution_principle/python)
## 注意事項
==**里氏替換原則 = 父類能被子類替換 = 繼承複用的規範**==

- 注意:
    - 不遵守規範 => 當前代碼沒有問題，未來出錯頻率會提高
    - ==聚合/組合 > 繼承(合成複用原則)==
        - 雖然里氏替換原則可以降低繼承關係帶給我們的副作用，但還是推薦使用聚合以及耦合關係