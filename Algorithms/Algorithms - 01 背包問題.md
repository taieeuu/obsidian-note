---
Date: 2024-10-31
tags:
  - Algorithm
---
### 01 背包概述
有n件物品和一個最多能背重量為w 的背包。第 i 件物品的重量是`weight[i]`，得到的價值是`value[i]`。 每件物品只能用一次 ，求解哪些物品裝入背包裡物品價值總和最大。

### 暴力解法
每一件物品其實只有兩個狀態，取或不取，所以可以用回溯法搜尋出所有的情況，那麼時間複雜度就是O(2^n)，這裡的n表示物品數量。

所以暴力的解法是指數級的時間複雜度。進而需要動態規劃的解法來進行最佳化！
### 使用 01 背包來解題 
舉例：
背包最大重量為4。

|     | 重量  | 价值  |
| --- | --- | --- |
| 物品0 | 1   | 15  |
| 物品1 | 3   | 20  |
| 物品2 | 4   | 30  |
問背包能背的物品最大價值是多少？
#### 動歸五部曲
1. 先確認 `dp` 數組的含義
2. 遞推公式
3. `dp` 初始化
4. 遍立順序
5. 驗證（打印）
##### dp 數組含義
`dp[i][j]`: `[0, 1]`物品，任取放進容量為 `j` 的背包中所能得到**最大價值**。
##### 遞推公式
背包只會有兩個狀態，放物品 i 或是不放物品 i 而已。

- **不放物品 i** : `dp[i-1][j]`，這邊的 `dp[i-1]` => 0 至 i-1 之間的物品，相當于就是不放物品 i。

- **放物品 i** : `dp[i-1][j-weight[i]] + value[i]` => `dp[i-1]`: 表示不放物品 i ，背包容量 - 物品 i 的容量所能放的最大價值。 `value[i]`: 放入物品 i 。`[j-weight[i]]`: 表示容量為 j 的背包，放入了物品，所以要減掉當前物品的重量。

最大價值: (背包容量 - 物品 i 的容量)，所能放的最大價值加上物品 i 的價值。

而由於我們要取最大價值所以公式會變成 => `dp[i][j] = max(dp[i-1][j-weight[i]] + value[i],d p[i-1][j])`。
##### 初始化
關於初始化，一定要和dp數組的定義吻合，否則到遞推公式的時候就會越來越亂 。首先從 `dp[i][j]` 的定義出發，如果背包容量 j 為 0 的話，即 `dp[i][0]`，無論是選取哪些物品，背包價值總和一定為0。

|     | 0   | 1   | 2   | 3   | 4   |
| --- | --- | --- | --- | --- | --- |
| 物品0 | 0   |     |     |     |     |
| 物品1 | 0   |     |     |     |     |
| 物品2 | 0   |     |     |     |     |
接下來再看，狀態轉移方程式 `dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);` 可以看出 i 是由 i-1 推導出來，那麼 i 為 0 的時候就一定要初始化。`dp[0][j]`，即：i 為 0，存放編號 0 的物品的時候，各個容量的背包所能存放的最大價值。那麼很明顯當 `j < weight[0]` 的時候，`dp[0][j]` 應該是 0，因為背包容量比編號0的物品重量還小。所以當`j >= weight[0]` 時，`dp[0][j]` 應該是 `value[0]`，因為背包容量放足夠放編號0物品。

|     | 0   | 1   | 2   | 3   | 4   |
| --- | --- | --- | --- | --- | --- |
| 物品0 | 0   | 15  | 15  | 15  | 15  |
| 物品1 | 0   |     |     |     |     |
| 物品2 | 0   |     |     |     |     |
##### 遍立順序
先遍立物品後遍立背包 or 先背包後物品都是可行的。（僅限二維）

因為數值都是由上方以及左斜方導出。